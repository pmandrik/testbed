### PART I intro
kernel - software that controls the hardware resources of the computer and provides an environment under which
programs can run  
layers: kernel - system calls - shell, library routines, applications  
operation system - kernel and all the other software that makes a computer useful and gives the computer its personality.  
shell - command-line interpreter that reads user input and executes commands  
File Descriptors - normally small non-negative integers that the kernel uses to identify the files accessed by a process  
stdin & stdout redirect : ./a.out < infile > outfile  
program - executable file residing on disk in a directory. A program is read into
memory and is executed by the kernel as a result of one exec function.
process - executing instance of a program.  
process ID - non-negative integer, unique numeric identifier.  
fork, exec and waitpid - basic functions to spawn and controll processes  
fork - create new process which is a cocpy of the caller  
exec - replace child process with new program file  
Threads share same adress space, file descriptors, stacks and process related attributes. Threads executed of its own stack but can access stack of other threads (same memory).  
User ID (0 for root) & Group ID used for permission checks.  
Signals - technique used to notify a process that some condition has occurred. We can ignore, provide a function to callor follow default behavior.  
Calendar time - the number of seconds since the Epoch:
00:00:00 January 1, 1970, Coordinated Universal Time (UTC).  
Process time (CPU time) - measures the central processor
resources used by a proces in clock ticks.  
Clock time - amount of time the process takes to run (depends on the number of other processes being run on the system).  
User CPU time - time attributed to user instruction.  
System CPU time - time attributed to kernel (e.g. read(), write(), system calls).  
System calls - limited number of entry points directly into the kernel  

### PART II standarts
POSIX - Portable Operating System Interface, operating system interface standard to promote the portability of applications among various UNIX. POSIX includes ISO C std library headers and optional headers.   
Single UNIX Specification - additional
interfaces that extend the functionality provided by the POSIX.1 specification.  
X/Open System Interfaces - describes optional interfaces
and defines which optional portions of POSIX.1 must be supported for an implementation to be deemed XSI conforming. Only XSI-
conforming implementations can be called UNIX systems.  
Linux - version of UNIX system (but not a UNIX system). Mac OS X - unix system, solaris - unix system. FreeBSD + others 3 are POSIX compilant more or less.   
Limits in implementation:
- compile-time limits (e.g., what’s the largest value of a short integer?)  
- Runtime limits (e.g., how many bytes in a filename?)  

could be fixed including e.g. header with INT_MAX max value of int.  
ISO C - <limits.h>  compile-time limits digits related. <float.h> for floating point. ISO C standard specifies minimum acceptable values. POSIX.1 makes extensions implementation must support, e.g. minimum value of 2,147,483,647 for INT_MAX.    
ISO C - FOPEN_MAX, minimum number
of standard I/O streams that the implementation guarantees can be open at once,  <stdio.h> - in POSIX.1 STREAM_MAX = FOPEN_MAX  
ISO C - TMP_MAX, maximum
number of unique filenames generated by the tmpnam function, <stdio.h>  
POSIX - provides multiple limits e.g. minimum "number of links to a file" implementation must provides (may can provide more), defined in limit.h or returned by sysconf, pathconf, and fpathconf calls.  
XSI - extra 5 constants.  

Options (optional interfaces) - may or maynot be in the system.
Compile-time options are defined in <unistd.h>, runtime options  in sysconf function or runtime options that are associated with a file or a directory are in pathconf and fpathconf.  

If the symbolic constant is undefined or −1 -> unsupported at compile time. If the symbolic constant > 0 -> option is supported.
If the symbolic constant = 0 -> call sysconf, pathconf, or fpathconf (replacing _XOPEN_UNIX -> _SC_XOPEN_UNIX, _POSIX_RAW_SOCKETS -> _SC_RAW_SOCKETS).  

### PART III I/O
Unbuffered I/O = read or write invokes a system call in the kernel  
In kernel  all open files are referred to by file descriptors (int > 0).  
In shell and many applications: STDIO - file descriptor 0, STDOUT - file descriptor 1, STDERR - file descriptor.  
FD returned by open and openat is guaranteed to be the lowest-numbered unused descriptor  

In kernel:  
- for every process table of open FD (FD flags, pointer to file table)  
- file table where for every file - file flag (read, write, append ...), offset, poiter to v-node table  
- v-node table contains file type info and functions operating on the file, and i-node (size, owner, pointer to data blocks, ...)  

v-node is file system-independed info  
i-node is file system-dependent  
If two processes have same file open -> have v-mode pointers to same v-node  
dup create a copy of FD - different process table entries with pointers to same file table  

When we write data to a file, kernel normally copie data into one of its buffers and queued for writing to disk at some later time (delayed write).  
sync function queues all the modified block buffers for writing and returns; not waiting for the disk writes to take place.  
sync is normally called periodically (~30s) by
system daemon  

fsync(int fd) waits for the disk writes into fd to complete before returning. Is used when needs to be sure that the modified blocks have been written to the disk.  
fdatasync(int fd) = fsync but only data not file’s attributes.  

fctnl - modify open file state  
ioctl - multiple io commands, terminal IO, socket IO, mag tape IO...  

### PART IV Files & Dirs

`stat()` - information (`struct stat`) about file using path  
`fstat()` - using file descriptor  
`lstat()` - information about symbolic link  
`fstatat()` - relative path (similare to openat)  

`struct stat` - file type, permissions, i-node number,
device number, owner user id (st_uid), owner group id (st_gid), size (bytes), time of last access, modification, major (device driver) and minor (subdevice) device numbers (st_dev) ... E.g. two file system on same disk -> same major, different minor. For block special files and character cpecial files we also have st_rdev with data from actual device.  
`st_size` - size in bytes for reg files, size of filename for link, ... directories.

File types =   
- regular file - data of some form
- directory - contains names and pointers to other files. Only kernel can write dir, any process - read.
- block special file - buffered IO access (fixed-size units) to devices
- character cpecial file - unbuffered IO access (variable-sized units) to devices
- FIFO (pipe) - used fo communication between processes
- socket - network communication between processes or non-network communication on a single host.
- symbolic link - file that point to another file.  

Every process has six or more IDs associated with it:
- real user ID, group ID from password file when we log in
- effective user ID, group ID, supplementary group ID = normally equals to the real IDs, but we can get IDs from file owner IDs
- saved set-user-ID, set-group-ID - copy of effective IDs from the begin of execution of program

File access permitions - 9 bites (User RWE, group RWE, other RWE). Read permission lets us read the directory, obtaining a list of all the filenames in the directory. Execute permission lets us pass through the directory. Access check:
1. if user ID == 0 -> pass
2. eff UID == file owner UID -> check bit -> pass
3. eff GID == file owner GID || any supplementary GID == file owner GID -> check bit -> pass
4. check other bit -> pass

when creating file - file UID = effective UID, file GID = dirrectory ID or effective GID.
S_ISVTX - sticky bit, when 1 in dir -> user can only remove file in dir if own file, e.g. in /tmp access only to owned files  

`access(path, int mode)` - check access eff UID to the file. Mode is F_OR or (R_OR|W_OR|X_OR)  
`faccessat(fd, path, mode, flag)` - relative to fd  
`umask(mode_t mask)` - sets the file mode creation mask for the process and returns the previous value. mode_t made from (S_IRUSR | S_IWUSR | S_IXUSR | S_IRGRP ... S_IROTH ). Turn 1 bits in creat() function into 0 if 1 if mask.  
`chmod(path, mode_t)` - change file access permission
also `fchmod(fd, mode_t)` & `fchmodat(fd, path, mode_t, flag)`. Change i-node update time.  
`chown(path, uid_t, gid_t)` - change file's UID & GID. Also `fchown(fd, uid, gid)`, `fchownat(fc, path, uid, gid, flag)`, `lchown(path, uid, gid)`. Check as `pathconf("fildir_1.txt", _PC_CHOWN_RESTRICTED);`  
`truncate(path, length)` - truncate file to length bytes. Also `ftruncate(fd, length)`  

UNIX file Systems:  
- UFS - traditional BSD-derived, Berkeley fast
file system
- PCFS - read and write DOS-formatted diskettes
- HSFS - read CD file

Disk -> partitions -> file sysyem [ boot block, super block, cylinder group ]  
cylinder group -> [ super block cp, cg info, i-node map, block bitmap, [ i-nodes ], data block ]  
Every i-node has a link count number of directory entries (st_nlink) that point to it. Only when the link count goes to 0 can the file be deleted. i-nodes  
points to data blocks and contains all info about file: file type, access bits, size.
When we create /A/ and /A/B dirs then:  
B directory block entry: "." -> B i-node, ".." -> A i-node  
A directory block entry: "." -> A i-node, ".." -> /, 
"B" -> B i-node.  
A i-node has 3 links, B i-node - 2 links.  
Hard link - pointed directly to i-node of the file (not across the system), part of directory entry.  
`link(path, newpath)` - create new directory entry which is copy of old entry (hard link).
Also we have `lintat(fd, path, newfd, newpath, flag)`.  
`unlink(path)` - remove directory entry, decrement i-node link count, when the link count reaches 0 can the contents of the file be deleted, as long as some
process has the file open, its contents will not be deleted. Can delete tmp file in case of crash. Remove symbolic link, not file. Also we have `unlinkat(fd, path, flag)`, AT_REMOVEDIR flag can remove directory. `remove(path)` - same as unlink or rmdir.  
`rename(path, newpath)` - mv file or dir. Also we have `renameat(fd, path, fd', new_path)` where path relative to fd, new_path relative to fd'  

Symbolic link - indirect pointer to a file, points to the data block containing file name.  
`symlink(path, symlink_path)` - create a symlink at symlink_path pointed to path. Also we have `symlinkat(path, fd, symlink_path)`.  
`readlink(path, char * buf, size_t)` - open and read name in the link. Also `readlinkat(fd, ...)`.  

`st_atim` - last-access time of file data (read)  
`st_mtim` - last-modification time of file data (write)  
`st_ctim` - last-change time of i-node status (chmod, chown)  

`futimens(fd, timespec t[st_atim, st_mtim])` - change file times (timespec is tricky). If t==null -> set timestams to now.
Also have `utimensat(fd, path, timespec[2], int flag)` and `utimes(path, timeval[st_atim, st_mtim])`. E.g. tar used this command to set times to date of archivation.  

`mkdir(path, mode_t)`, `mkdirat(fd, path, mode_t)` - create directory. To allo access to filenames we need execute bits!  
`rmdir(path)` - delete empty directory (until no other process has the directory open). No new files can be created in the directory.  

`DIR* opendir(path)` & `DIR* fdopendirat(fd)` - get DIR from path or fd.  
`dirent* dirp readdir(DIR *)` - return directory item as struct with d_ino - i-node number, d_name[<NAME_MAX] - filename.  
`rewinddir(DIR*)` - resets the position of the directory stream to which dirp refers to the beginning of the directory.  
`closedir(DIR*)`  
`long telldir(DIR*)` - return current location in directory stream.  
`seekdir(DIR*, long loc)` - set the position of the next readdir() call in the directory stream.  
`chdir(path)` & `fchdir(fd)` - change current working directory process has.  
`char* getcwd(char* buf, size_t)` - return pwd path.  

### PART V Standart I/O
`FILE *` - file pointer. We have predefined file pointers `stdion`, `stdout` and `stderr` defined in <stdio.h>.   
`FILE* fopen(path, const char* rmode)` - open a file; rmode = `r`, `w` truncate and open to write, `a` read at end of file, `r+` -reand and write, `w+`, `a+`; `rb` - for binary. Create files with permission bits: S_IRUSR | S_IWUSR | S_IRGRP | S_IWGRP | S_IROTH | S_IWOTH.`freopen(path, type, FILE*)` - open file at specific stream, closing if already exist. `fdopen(int, char*)` - associates a standard I/O stream with the descriptor.  
`fclose(FILE*)` - close file stream.  

The goal of the std IO buffering is to use the minimum number of `read` and `write` calls:  
- fully buffered - StdIO will call malloc, IO operations (flush to write) when buffer is filled.  
- line buffered - IO operations when newline character is encountered (e.g. terminal stdio, stdout).   
- unbuffered - no buffer, output as soon as possible, e.g. stderr.  
`setbuf(FILE*, char* buf)` - buf = NULL to disable buffering, buf = BUFSIZ - enable buffering. Call before any other operation is performed on the stream. `setvbuf(FILE*, buf, mode, size)` - mode = _IOFBF
fully buffered, mode = _IOLBF line buffered, mode = _IONBF unbuffered; buf & size - specify buffer size, when buf = NULL -> StdIO automatic allocation.  
`fflush(FILE*)` - pass data to kernel. If `flush(NULL)` will call all output streams.  

Unformatted I/O:  
- Character-at-a-time I/O -  read or write one character at a time  
- Line-at-a-time I/O -  read or write a line at a time  
- Direct I/O - read or write with a specified size.  

`int ferror(FILE*) / feof(FILE*)` - return > 0 if error / if eof.
`clearerr(FILE*)` - clear error/eof flags.  

`int getc(FILE*)` - return the next character.
`fgetc(FILE*)` - guaranteed to be a function, while getc can be a macro.
`getchar() = getc(stdio)`.
`int ungetc(int, FILE*)` - push character back to the stream.  
`int putc(int c, FILE*)`, `fputc(..)`, `putchar(..)` - put character.  

`char* fgets(char* buf, int n, FILE* fp)` - read line into buf, no more than n-1 characters.
`gets(char* buf) = fgets(stdio)`  
`int fputs(char* str, FILE*)` & `int puts(char*str)` - write null-terminated string.

`fread(void* ptr, size_t size, size_t nobj, FILE*)` - read `nobj` with `size` from FILE.  
`fwrite(void* ptr, size, size_t nobj, FILE*)` - e.g. fwrite(&data[2], sizeof(float), 4, fp). Note, StdIO binary format is implementation dependent - problems to read files from other systems.   

`long ftell(FILE*)` - measure in bytes from the beginning of the file.  
`int fseek(FILE*, offset, whence)` - set position where whence same as fpr lseek.  
`rewind(FILE*)` - move to start.  
With bigger posible position size we have `off_t ftello` & `fseeko` functions.
Event more bigger `fgetpos(FILE*, fpos_t*)` & `fsetpos(FILE*, fpos_t*)`.  

Formatted output:
`printf(...)`, `fprintf(FILE* ...)`, `dprintf(FD ...)`
`sprintf(char* buf...)`, `snprintf(char* buf, size_t n ...)` - with size of the buffer.  

Formatted input:
`scanf()`, `fscanf()`, `sscanf()`  

`int fileno(FILE *fp)` - get FD from FILE  
`fwide(FILE *, int mode)` - if `mode < 0` -> set stream byte oriented; `mode > 0` -> wide oriented;  
























