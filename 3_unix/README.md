### PART I intro
kernel - software that controls the hardware resources of the computer and provides an environment under which
programs can run  
layers: kernel - system calls - shell, library routines, applications  
operation system - kernel and all the other software that makes a computer useful and gives the computer its personality.  
shell - command-line interpreter that reads user input and executes commands  
File Descriptors - normally small non-negative integers that the kernel uses to identify the files accessed by a process  
stdin & stdout redirect : ./a.out < infile > outfile  
program - executable file residing on disk in a directory. A program is read into
memory and is executed by the kernel as a result of one exec function.
process - executing instance of a program.  
process ID - non-negative integer, unique numeric identifier.  
fork, exec and waitpid - basic functions to spawn and controll processes  
fork - create new process which is a cocpy of the caller  
exec - replace child process with new program file  
Threads share same adress space, file descriptors, stacks and process related attributes. Threads executed of its own stack but can access stack of other threads (same memory).  
User ID (0 for root) & Group ID used for permission checks.  
Signals - technique used to notify a process that some condition has occurred. We can ignore, provide a function to callor follow default behavior.  
Calendar time - the number of seconds since the Epoch:
00:00:00 January 1, 1970, Coordinated Universal Time (UTC).  
Process time (CPU time) - measures the central processor
resources used by a proces in clock ticks.  
Clock time - amount of time the process takes to run (depends on the number of other processes being run on the system).  
User CPU time - time attributed to user instruction.  
System CPU time - time attributed to kernel (e.g. read(), write(), system calls).  
System calls - limited number of entry points directly into the kernel  

### PART II standarts
POSIX - Portable Operating System Interface, operating system interface standard to promote the portability of applications among various UNIX. POSIX includes ISO C std library headers and optional headers.   
Single UNIX Specification - additional
interfaces that extend the functionality provided by the POSIX.1 specification.  
X/Open System Interfaces - describes optional interfaces
and defines which optional portions of POSIX.1 must be supported for an implementation to be deemed XSI conforming. Only XSI-
conforming implementations can be called UNIX systems.  
Linux - version of UNIX system (but not a UNIX system). Mac OS X - unix system, solaris - unix system. FreeBSD + others 3 are POSIX compilant more or less.   
Limits in implementation:
- compile-time limits (e.g., what’s the largest value of a short integer?)  
- Runtime limits (e.g., how many bytes in a filename?)  

could be fixed including e.g. header with INT_MAX max value of int.  
ISO C - <limits.h>  compile-time limits digits related. <float.h> for floating point. ISO C standard specifies minimum acceptable values. POSIX.1 makes extensions implementation must support, e.g. minimum value of 2,147,483,647 for INT_MAX.    
ISO C - FOPEN_MAX, minimum number
of standard I/O streams that the implementation guarantees can be open at once,  <stdio.h> - in POSIX.1 STREAM_MAX = FOPEN_MAX  
ISO C - TMP_MAX, maximum
number of unique filenames generated by the tmpnam function, <stdio.h>  
POSIX - provides multiple limits e.g. minimum "number of links to a file" implementation must provides (may can provide more), defined in limit.h or returned by sysconf, pathconf, and fpathconf calls.  
XSI - extra 5 constants.  

Options (optional interfaces) - may or maynot be in the system.
Compile-time options are defined in <unistd.h>, runtime options  in sysconf function or runtime options that are associated with a file or a directory are in pathconf and fpathconf.  

If the symbolic constant is undefined or −1 -> unsupported at compile time. If the symbolic constant > 0 -> option is supported.
If the symbolic constant = 0 -> call sysconf, pathconf, or fpathconf (replacing _XOPEN_UNIX -> _SC_XOPEN_UNIX, _POSIX_RAW_SOCKETS -> _SC_RAW_SOCKETS).  

### PART III I/O
Unbuffered I/O = read or write invokes a system call in the kernel  
In kernel  all open files are referred to by file descriptors (int > 0).  
In shell and many applications: STDIO - file descriptor 0, STDOUT - file descriptor 1, STDERR - file descriptor.  
FD returned by open and openat is guaranteed to be the lowest-numbered unused descriptor  

In kernel:  
- for every process table of open FD (FD flags, pointer to file table)  
- file table where for every file - file flag (read, write, append ...), offset, poiter to v-node table  
- v-node table contains file type info and functions operating on the file, and i-node (size, owner, pointer to data blocks, ...)  

v-node is file system-independed info  
i-node is file system-dependent  
If two processes have same file open -> have v-mode pointers to same v-node  
dup create a copy of FD - different process table entries with pointers to same file table  

When we write data to a file, kernel normally copie data into one of its buffers and queued for writing to disk at some later time (delayed write).  
sync function queues all the modified block buffers for writing and returns; not waiting for the disk writes to take place.  
sync is normally called periodically (~30s) by
system daemon  

`fsync(int fd)` waits for the disk writes into fd to complete before returning. Is used when needs to be sure that the modified blocks have been written to the disk.  
`fdatasync(int fd)` = fsync but only data not file’s attributes.  

`fctnl` - modify open file state  
`ioctl` - multiple io commands, terminal IO, socket IO, mag tape IO...  

### PART IV Files & Dirs

`stat()` - information (`struct stat`) about file using path  
`fstat()` - using file descriptor  
`lstat()` - information about symbolic link  
`fstatat()` - relative path (similare to openat)  

`struct stat` - file type, permissions, i-node number,
device number, owner user id (st_uid), owner group id (st_gid), size (bytes), time of last access, modification, major (device driver) and minor (subdevice) device numbers (st_dev) ... E.g. two file system on same disk -> same major, different minor. For block special files and character cpecial files we also have st_rdev with data from actual device.  
`st_size` - size in bytes for reg files, size of filename for link, ... directories.

File types =   
- regular file - data of some form
- directory - contains names and pointers to other files. Only kernel can write dir, any process - read.
- block special file - buffered IO access (fixed-size units) to devices
- character cpecial file - unbuffered IO access (variable-sized units) to devices
- FIFO (pipe) - used fo communication between processes
- socket - network communication between processes or non-network communication on a single host.
- symbolic link - file that point to another file.  

Every process has six or more IDs associated with it:
- real user ID, group ID from password file when we log in
- effective user ID, group ID, supplementary group ID = normally equals to the real IDs, but we can get IDs from file owner IDs
- saved set-user-ID, set-group-ID - copy of effective IDs from the begin of execution of program

File access permitions - 9 bites (User RWE, group RWE, other RWE). Read permission lets us read the directory, obtaining a list of all the filenames in the directory. Execute permission lets us pass through the directory. Access check:
1. if user ID == 0 -> pass
2. eff UID == file owner UID -> check bit -> pass
3. eff GID == file owner GID || any supplementary GID == file owner GID -> check bit -> pass
4. check other bit -> pass

when creating file - file UID = effective UID, file GID = dirrectory ID or effective GID.
S_ISVTX - sticky bit, when 1 in dir -> user can only remove file in dir if own file, e.g. in /tmp access only to owned files  

`access(path, int mode)` - check access eff UID to the file. Mode is F_OR or (R_OR|W_OR|X_OR)  
`faccessat(fd, path, mode, flag)` - relative to fd  
`umask(mode_t mask)` - sets the file mode creation mask for the process and returns the previous value. mode_t made from (S_IRUSR | S_IWUSR | S_IXUSR | S_IRGRP ... S_IROTH ). Turn 1 bits in creat() function into 0 if 1 if mask.  
`chmod(path, mode_t)` - change file access permission
also `fchmod(fd, mode_t)` & `fchmodat(fd, path, mode_t, flag)`. Change i-node update time.  
`chown(path, uid_t, gid_t)` - change file's UID & GID. Also `fchown(fd, uid, gid)`, `fchownat(fc, path, uid, gid, flag)`, `lchown(path, uid, gid)`. Check as `pathconf("fildir_1.txt", _PC_CHOWN_RESTRICTED);`  
`truncate(path, length)` - truncate file to length bytes. Also `ftruncate(fd, length)`  

UNIX file Systems:  
- UFS - traditional BSD-derived, Berkeley fast
file system
- PCFS - read and write DOS-formatted diskettes
- HSFS - read CD file

Disk -> partitions -> file sysyem [ boot block, super block, cylinder group ]  
cylinder group -> [ super block cp, cg info, i-node map, block bitmap, [ i-nodes ], data block ]  
Every i-node has a link count number of directory entries (st_nlink) that point to it. Only when the link count goes to 0 can the file be deleted. i-nodes  
points to data blocks and contains all info about file: file type, access bits, size.
When we create /A/ and /A/B dirs then:  
B directory block entry: "." -> B i-node, ".." -> A i-node  
A directory block entry: "." -> A i-node, ".." -> /, 
"B" -> B i-node.  
A i-node has 3 links, B i-node - 2 links.  
Hard link - pointed directly to i-node of the file (not across the system), part of directory entry.  
`link(path, newpath)` - create new directory entry which is copy of old entry (hard link).
Also we have `lintat(fd, path, newfd, newpath, flag)`.  
`unlink(path)` - remove directory entry, decrement i-node link count, when the link count reaches 0 can the contents of the file be deleted, as long as some
process has the file open, its contents will not be deleted. Can delete tmp file in case of crash. Remove symbolic link, not file. Also we have `unlinkat(fd, path, flag)`, AT_REMOVEDIR flag can remove directory. `remove(path)` - same as unlink or rmdir.  
`rename(path, newpath)` - mv file or dir. Also we have `renameat(fd, path, fd', new_path)` where path relative to fd, new_path relative to fd'  

Symbolic link - indirect pointer to a file, points to the data block containing file name.  
`symlink(path, symlink_path)` - create a symlink at symlink_path pointed to path. Also we have `symlinkat(path, fd, symlink_path)`.  
`readlink(path, char * buf, size_t)` - open and read name in the link. Also `readlinkat(fd, ...)`.  

`st_atim` - last-access time of file data (read)  
`st_mtim` - last-modification time of file data (write)  
`st_ctim` - last-change time of i-node status (chmod, chown)  

`futimens(fd, timespec t[st_atim, st_mtim])` - change file times (timespec is tricky). If t==null -> set timestams to now.
Also have `utimensat(fd, path, timespec[2], int flag)` and `utimes(path, timeval[st_atim, st_mtim])`. E.g. tar used this command to set times to date of archivation.  

`mkdir(path, mode_t)`, `mkdirat(fd, path, mode_t)` - create directory. To allo access to filenames we need execute bits!  
`rmdir(path)` - delete empty directory (until no other process has the directory open). No new files can be created in the directory.  

`DIR* opendir(path)` & `DIR* fdopendirat(fd)` - get DIR from path or fd.  
`dirent* dirp readdir(DIR *)` - return directory item as struct with d_ino - i-node number, d_name[<NAME_MAX] - filename.  
`rewinddir(DIR*)` - resets the position of the directory stream to which dirp refers to the beginning of the directory.  
`closedir(DIR*)`  
`long telldir(DIR*)` - return current location in directory stream.  
`seekdir(DIR*, long loc)` - set the position of the next readdir() call in the directory stream.  
`chdir(path)` & `fchdir(fd)` - change current working directory process has.  
`char* getcwd(char* buf, size_t)` - return pwd path.  

### PART V Standart I/O
`FILE *` - file pointer. We have predefined file pointers `stdion`, `stdout` and `stderr` defined in <stdio.h>.   
`FILE* fopen(path, const char* rmode)` - open a file; rmode = `r`, `w` truncate and open to write, `a` read at end of file, `r+` -reand and write, `w+`, `a+`; `rb` - for binary. Create files with permission bits: S_IRUSR | S_IWUSR | S_IRGRP | S_IWGRP | S_IROTH | S_IWOTH.`freopen(path, type, FILE*)` - open file at specific stream, closing if already exist. `fdopen(int, char*)` - associates a standard I/O stream with the descriptor.  
`fclose(FILE*)` - close file stream.  

The goal of the std IO buffering is to use the minimum number of `read` and `write` calls:  
- fully buffered - StdIO will call malloc, IO operations (flush to write) when buffer is filled.  
- line buffered - IO operations when newline character is encountered (e.g. terminal stdio, stdout).   
- unbuffered - no buffer, output as soon as possible, e.g. stderr.  
`setbuf(FILE*, char* buf)` - buf = NULL to disable buffering, buf = BUFSIZ - enable buffering. Call before any other operation is performed on the stream. `setvbuf(FILE*, buf, mode, size)` - mode = _IOFBF
fully buffered, mode = _IOLBF line buffered, mode = _IONBF unbuffered; buf & size - specify buffer size, when buf = NULL -> StdIO automatic allocation.  
`fflush(FILE*)` - pass data to kernel. If `flush(NULL)` will call all output streams.  

Unformatted I/O:  
- Character-at-a-time I/O -  read or write one character at a time  
- Line-at-a-time I/O -  read or write a line at a time  
- Direct I/O - read or write with a specified size.  

`int ferror(FILE*) / feof(FILE*)` - return > 0 if error / if eof.
`clearerr(FILE*)` - clear error/eof flags.  

`int getc(FILE*)` - return the next character.
`fgetc(FILE*)` - guaranteed to be a function, while getc can be a macro.
`getchar() = getc(stdio)`.
`int ungetc(int, FILE*)` - push character back to the stream.  
`int putc(int c, FILE*)`, `fputc(..)`, `putchar(..)` - put character.  

`char* fgets(char* buf, int n, FILE* fp)` - read line into buf, no more than n-1 characters.
`gets(char* buf) = fgets(stdio)`  
`int fputs(char* str, FILE*)` & `int puts(char*str)` - write null-terminated string.

`fread(void* ptr, size_t size, size_t nobj, FILE*)` - read `nobj` with `size` from FILE.  
`fwrite(void* ptr, size, size_t nobj, FILE*)` - e.g. fwrite(&data[2], sizeof(float), 4, fp). Note, StdIO binary format is implementation dependent - problems to read files from other systems.   

`long ftell(FILE*)` - measure in bytes from the beginning of the file.  
`int fseek(FILE*, offset, whence)` - set position where whence same as fpr lseek.  
`rewind(FILE*)` - move to start.  
With bigger posible position size we have `off_t ftello` & `fseeko` functions.
Event more bigger `fgetpos(FILE*, fpos_t*)` & `fsetpos(FILE*, fpos_t*)`.  

Formatted output:
`printf(...)`, `fprintf(FILE* ...)`, `dprintf(FD ...)`; 
`sprintf(char* buf...)`, `snprintf(char* buf, size_t n ...)` - with size of the buffer.  

Formatted input:
`scanf()`, `fscanf()`, `sscanf()`  

Temporary files:
`char* tmpnam(char* pathv)` - generate  generates valid pathname (write into pathv or into member array) and that does not match the name of any existing file, up to TMP_MAX. Also `tempnam` obsolet.  
`FILE* tmpfile()` - create TMP (`wb+`) that is automatically removed when it is closed.  
`char* mkdtemp(char* template)` - create a directory, return dir name; template - pathname ended with XXXXXX.  
`int mkstemp(char* template)` - create a regular file, return FD, do not unlink.  

`int fileno(FILE *fp)` - get FD from FILE.  
`fwide(FILE *, int mode)` - if `mode < 0` -> set stream byte oriented; `mode > 0` -> wide oriented;  

Memory streams - buffering without underlying files.  
`FILE* fmemopen(void* buf, size_t size_of_buf, char* type)` - provide a buffer to be used for the memory stream (we have internal buffer as usual and buf as replacement for output file), type = {`r`, `w`, `a` - write at first null byte, `w+` - truncate, `a+`, +`b` for binary}. If buf = NULL -> allocate.  
`FILE* open_memstream(char** buf, size_t *size)` -  byte oriented mem stream for writing which care about creation and size of buffers; but we need to free memory from buffers. Need to flush to set up pointers.  
`FILE* open_wmemstream(...)` - wide oriented mem stream.  

### PART VI System Data Files and Information
In <pwd.h> we have:  
`struct passwd *getpwuid(uid_t uid)` - passwd from user id from i-node info.  
`struct passwd *getpwnam(char*)` - from user name. `spwd* getspnam(char*)` for shadow file.  

To iterate over passwd file entries:  
`setpwent()` `passwd ptr = getpwent()` `endpwent()`  
To iterate over shadows file entries <shadow.h>:  
`setspent()` `passwd ptr = getspent()` `endspent()`  

Similare for groups <grp.h>:  
`group *getgrgid(gid_t gid)`, `group *getgrnam(const char *name)`, `group *getgrent(void)`, `setgrent(void)`, `endgrent(void)`  

Supplementary group IDs:  
`int getgroups(int N, gid_t grouplist[])` - get up to N groups IDs into grouplist, return actual size. For N=0 return only number of groups.  
`int setgroups(int N, const gid_t grouplist[])` - set groups IDs for the callig process.  
`int initgroups(const char *user, gid_t gid)` - set groups IDs for user, including gid group (e.g. from password file).  

Numerous other system data files: `/etc/services`, `/etc/protocols`, `/etc/networks` with at least `get` function to read next record in data file, `set` for rewind and `end` function to close data file. Files to track users loggins: 
`utmp` - all users currently logged.
`wtmp` - all logins and logout.  

`int uname(struct utsname *name)` - return information on the current host and operating system (sysname, nodename, release, version, machine, ...).  
`int gethostname(char *name, int namelen)` - get hostname.  

POSIX support multiple clocks:
`time_t time(time_t *calptr)` - current value of time; `int clock_gettime(clockid_t id, timespec *tsp)` - timespec from clock with id; `int clock_getres(clockid_t id, timespec *tsp)`- get resolution; `int clock_settime(clockid_t id, timespec *tsp)` - set time.  

kernel -> (time) -> time_t  
kernel -> (clock_gettime) -> timespec -> (tv_sec) -> time_t -> (gmtime/localtime) -> tm -> (strftime) -> formatted string -> (strptime) -> tm -> (mktime) -> time_t  

### PART VII Process Environment
`char* getenv(char* name)` - return value by name.  
`int putenv(char* str)`, `int setenv(char* name, char* value, int rewrite)` - add std="name=value" to enviroment.  
`int unsetenv(char* name)` - remove name from ENV.  

`int setjmp(jmp_buf env)` - set mark for jump, return 0.  
`void longjmp(jmp_buf env, int val)` - jump, causes setjump to return val. Reroll stack memory. Maybe roll back automatic variables and register (stored in CPU) variables. GCC with optimisation may move auto variable into register.

`int getrlimit(int resource, struct rlimit *rlptr)` - get soft and hard rlimit={rlim_cur, rlim_max} for resource e.g. RLIMIT_AS.  
`int setrlimit(int resource, const struct rlimit *rlptr)`.  

When a C program is executed by the kernel (one of exec functions) - start-up routine is called, taking executable program file as the starting address for the program given by link editor called by C compiler. Start-up routine takes values from the kernel—the command-line arguments and the environment (`extern char **environ`) and call main function.  
`int main(int argc, char * argv[])`  
Process termination:
- `return x` from main = `exit(x)`
- call `exit(int status)` - cleanup such as fclose to all open streams, flush, call exit handlers defined as `int atexit(void (*func)(void))`. Then call `_exit`..
- call `_exit(int status)` (POSIX) / `_Exit(int statis)` (ISO C) - return to kernel immediately
- return from last thread
- call `pthread_exit`
- call `abort`
- receipt `signal`
- something connected to threads

C program composed from (maybe from low address):
- text segment - instructions CPU executes (saved on disk).  
- initialized data - data segment, containing variables declaration e.g. `int a = 88;` outside functions (saved on disk).
- uninitialized data segment e.g. `long sum[1000];` outside functions.
- heap - dynamic memory allocation (between uninitialized data and stack).
- stack - automatic variables from functions, at high adress. Then command-line arguments and enviroment.

Memory allocations (note alternative allocation functions):  
`void *malloc(size_t size)` - allocates a specified number of bytes of memory. Using sbrk system call.  
`void *calloc(size_t nobj, size_t size)` - which allocates space for a specified number of objects of a specified size.  
`void *realloc(void *ptr, size_t newsize)` -  increases/decreases the size of a previously allocated area; when increases - involve moving the previously allocated area somewhere else & space between the old contents and the end of the new area is indeterminate.  
`void free(void *ptr)` - deallocate. Usually keep space in malloc pool not returning to the kernel.  

### PART VIII Process Control
`pid_t getpid(void)`,`pid_t getppid(void)` - process id and parent process id.

`pid_t fork(void)` - create child process (in child return 0, in parent return child pid). Child get a copy of parents data, heap and stack and share text segment. In modern implementation - read-only data, heap, stack and when child is trying to modify -> then a copy. fork to create new process, exec to initiate new program. parent and child process share same file table entry (same file status flags, v-node pointer, current file offset).
Child inherited from parent: real UID, real GID, eff UID, eff GID, supplementary GIDs, resource limits, memory mapping, shared memory segments (?), enviroment, session ID, process group ID, terminal, working dir, umask, signal mask & disposition(?).  
Differences: fork return values, process IDs, parent process IDs, tms_* times are 0, pending alarms, set of pending signals, file locks.  

`vfork` -  guarantees that the child runs first, do not copy address space.  

`init process` (pid = 1) becomes the parent process of any process whose parent terminates - every process has a parent guarante.  

`pid_t wait(int* statloc)` - block if children are still running, return termination child pid (write status into statloc) if child has terminated (zombie), return if no any child process. Return on first child terminates.  
`pid_t waitpid(pid_t pid, int * statloc, int options)` - if pid  == -1 - wait for any child; pid == 0 - wait for any child with same process group ID as caller; pid > 0 - wait for pid child; pid < -1 - wait for any child with process group ID equals the |pid|. options = WCONTINUED - wait continued child, WNOHANG - no block if child is working and return 0, WUNTRACED - wait child that has stopped.  
When process terminates -> kernel notify parent by SIGCHLD signal.
Zombie process - is child that terminated but parent not yet waited for it.  

To check termination status:
- WIFEXITED(status) - true if child terminated normally.
- WIFSIGNALED(status) - true if child terminated abnormally by signal.
- WIFSTOPPED(status) - true if child currently stopped.
- WIFCONTINUED(status) - true if child has been continued after job conrol stop.

`int waitid(idtype_t id, id_t id, siginfo_t* infop, int options)` - 
idtype: P_PID - particular process with `id`, P_PGID - any child from process group `id`, P_ALL - any child; options: WCONTINUED, WEXITED - wait terminated, WNOHANG, WSTOPPED, WNOWAIT - let child be waited later.  

`pid_t wait3(int* statloc, int options, rusage*)`, `pid_t wait4(pid_t pid, int* statloc, int options, rusage*)` - same as wait but return resource informations.

Seven exec functions:
`int execl(path, agrs)`, `execv(...)`, `execle(...)`, `execve(...)`, `execlp(filename, agrs)` - filename is path or file in PATH. if found not executable will try run via /bin/sh. `execvp(...)`, `fexecve(int fd, ...)` - safer as FD could not be replaced. Can take enviroment array instead of environ.
File flag FD_CLOEXEC -> FD is closed across an exec.

Least-privilege design - programs should use the least privilege necessary to given task: `setuid(uid_t uid)`, `setgid(gid_t gid)` - root will set real UID, eff UID, saved set-UID; not-root will set eff UID to real UID or saved set-UID. Set-UID & eff UID is taken from executable set-UID bit. Real UID is set by login program.  
`seteuid(uid_t uid)`& `setegid(gid_t gid)` - set only effective ids.  

`#! pathname [ optional-argument ]` - interpreter files e.g. `#!/bin/awk -f`, `#!/bin/sh`  

`int system(char * cmd)` - to call shell command. Inside it is fork+exec+waipid

Process scheduling - lower nice values have higher scheduling priority.  
`int nice(int incr)` - increment and return nice value. Also `int getpriority(int which = {PRIO_PROCESS, PRIO_PGRP, PRIO_USER}, id_t who);` & `int setpriority(int which, id_t who, int value);`  

`clock_t times(struct tms *buf )` - fill tms with user, system time, return wall time.

### PART IX Process Relationships
Each process belongs to a process group - collection of one or more processes, that can receive signals from the same call.  
We can send a signal to either a single process (identified by its process ID) or a process group (identified by its process group ID).  
Each process group can have a process group leader. The leader process ID is equal to process group ID.  
`pid_t getpgrp(void);` returns: process group ID of calling process  
`pid_t getpgid(pid_t pid);` returns: process group ID if OK, −1 on error  

A session is a collection of one or more process groups. A session leader is the process that creates a session. A session leader has no controlling terminal.
- session can have a single controlling terminal.
- session leader that establishes the connection to the controlling terminal is called the controlling process
- process in session can be divided into a one foreground group and one or more background groups
- whenever we press terminal’s interrupt key, the interrupt signal is sent to the foreground process group.
- whenever we press the terminal’s quit key, the quit signal is sent to the foreground process group.
- if network disconnect is detected by the terminal interface, the hang-up signal is sent to the session leader.

The way a program can guarantees that it is talking to the controlling terminal is to open the file /dev/tty.
- The interrupt character (DELETE or Control-C) generates SIGINT.
- The quit character (Control-backslash) generates SIGQUIT.
- The suspend character (Control-Z) generates SIGTSTP.







